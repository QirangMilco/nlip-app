// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'nlip_api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `create_client`
// These functions are ignored because they have generic arguments: `api_request`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ApiResponse`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

String greet({required String name}) =>
    RustLib.instance.api.crateApiNlipApiGreet(name: name);

Future<LoginResponse> login({
  required String serverUrl,
  required String username,
  required String token,
}) => RustLib.instance.api.crateApiNlipApiLogin(
  serverUrl: serverUrl,
  username: username,
  token: token,
);

Future<ClipResponse> getLastClip({
  required String serverUrl,
  required String token,
  required String spaceId,
}) => RustLib.instance.api.crateApiNlipApiGetLastClip(
  serverUrl: serverUrl,
  token: token,
  spaceId: spaceId,
);

Future<ClipResponse> uploadTextClip({
  required String serverUrl,
  required String token,
  required String spaceId,
  required String content,
}) => RustLib.instance.api.crateApiNlipApiUploadTextClip(
  serverUrl: serverUrl,
  token: token,
  spaceId: spaceId,
  content: content,
);

Future<SpacesListResponse> getSpacesList({
  required String serverUrl,
  required String token,
}) => RustLib.instance.api.crateApiNlipApiGetSpacesList(
  serverUrl: serverUrl,
  token: token,
);

Future<CreateSpaceResponse> createSpace({
  required String serverUrl,
  required String token,
  required String name,
}) => RustLib.instance.api.crateApiNlipApiCreateSpace(
  serverUrl: serverUrl,
  token: token,
  name: name,
);

@freezed
sealed class ApiError with _$ApiError implements FrbException {
  const ApiError._();

  const factory ApiError.networkError(String field0) = ApiError_NetworkError;
  const factory ApiError.serverError({
    required int code,
    required String message,
  }) = ApiError_ServerError;
  const factory ApiError.deserializeError(String field0) =
      ApiError_DeserializeError;
  const factory ApiError.other(String field0) = ApiError_Other;
}

class Clip {
  final String id;
  final String clipId;
  final String spaceId;
  final String content;
  final String contentType;
  final ClipCreator creator;
  final String createdAt;
  final String updatedAt;
  final String filePath;

  const Clip({
    required this.id,
    required this.clipId,
    required this.spaceId,
    required this.content,
    required this.contentType,
    required this.creator,
    required this.createdAt,
    required this.updatedAt,
    required this.filePath,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      clipId.hashCode ^
      spaceId.hashCode ^
      content.hashCode ^
      contentType.hashCode ^
      creator.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      filePath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Clip &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          clipId == other.clipId &&
          spaceId == other.spaceId &&
          content == other.content &&
          contentType == other.contentType &&
          creator == other.creator &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          filePath == other.filePath;
}

class ClipCreator {
  final String id;
  final String username;

  const ClipCreator({required this.id, required this.username});

  @override
  int get hashCode => id.hashCode ^ username.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClipCreator &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          username == other.username;
}

class ClipResponse {
  final Clip clip;

  const ClipResponse({required this.clip});

  @override
  int get hashCode => clip.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClipResponse &&
          runtimeType == other.runtimeType &&
          clip == other.clip;
}

class CreateSpaceResponse {
  final Space space;

  const CreateSpaceResponse({required this.space});

  @override
  int get hashCode => space.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateSpaceResponse &&
          runtimeType == other.runtimeType &&
          space == other.space;
}

class LoginResponse {
  final String jwtToken;
  final User user;

  const LoginResponse({required this.jwtToken, required this.user});

  @override
  int get hashCode => jwtToken.hashCode ^ user.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LoginResponse &&
          runtimeType == other.runtimeType &&
          jwtToken == other.jwtToken &&
          user == other.user;
}

class Space {
  final String id;
  final String name;
  final String typeField;
  final String ownerId;
  final int maxItems;
  final int retentionDays;
  final String createdAt;
  final String updatedAt;

  const Space({
    required this.id,
    required this.name,
    required this.typeField,
    required this.ownerId,
    required this.maxItems,
    required this.retentionDays,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      typeField.hashCode ^
      ownerId.hashCode ^
      maxItems.hashCode ^
      retentionDays.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Space &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          typeField == other.typeField &&
          ownerId == other.ownerId &&
          maxItems == other.maxItems &&
          retentionDays == other.retentionDays &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

class SpacesListResponse {
  final List<Space> spaces;

  const SpacesListResponse({required this.spaces});

  @override
  int get hashCode => spaces.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpacesListResponse &&
          runtimeType == other.runtimeType &&
          spaces == other.spaces;
}

class User {
  final String id;
  final String username;
  final bool isAdmin;
  final bool needChangePwd;
  final String createdAt;

  const User({
    required this.id,
    required this.username,
    required this.isAdmin,
    required this.needChangePwd,
    required this.createdAt,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      username.hashCode ^
      isAdmin.hashCode ^
      needChangePwd.hashCode ^
      createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is User &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          username == other.username &&
          isAdmin == other.isAdmin &&
          needChangePwd == other.needChangePwd &&
          createdAt == other.createdAt;
}
